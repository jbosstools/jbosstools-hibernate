<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;19.&nbsp;Improving performance</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"><link rel="previous" href="xml.html" title="Chapter&nbsp;18.&nbsp;XML Mapping"><link rel="next" href="toolsetguide.html" title="Chapter&nbsp;20.&nbsp;Toolset Guide"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;19.&nbsp;Improving performance</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="xml.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="toolsetguide.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;19.&nbsp;Improving performance</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-fetching"></a>19.1.&nbsp;Fetching strategies</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>fetching strategy</em></span> is the strategy Hibernate will use for 
            retrieving associated objects if the application needs to navigate the association. 
            Fetch strategies may be declared in the O/R mapping metadata, or over-ridden by a 
            particular HQL or <tt class="literal">Criteria</tt> query.
        </p><p>
            Hibernate3 defines the following fetching strategies:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Join fetching</em></span> - Hibernate retrieves the
                    associated instance or collection in the same <tt class="literal">SELECT</tt>,
                    using an <tt class="literal">OUTER JOIN</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>Select fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated entity or collection. Unless
                    you explicitly disable lazy fetching by specifying <tt class="literal">lazy="false"</tt>, 
                    this second select will only be executed when you actually access the
                    association.
                </p></li><li><p>
                    <span class="emphasis"><em>Subselect fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated collections for all entities retrieved in a
                    previous query or fetch. Unless you explicitly disable lazy fetching by specifying 
                    <tt class="literal">lazy="false"</tt>, this second select will only be executed when you 
                    actually access the association.
                </p></li><li><p>
                    <span class="emphasis"><em>Batch fetching</em></span> - an optimization strategy
                    for select fetching - Hibernate retrieves a batch of entity instances 
                    or collections in a single <tt class="literal">SELECT</tt>, by specifying 
                    a list of primary keys or foreign keys.
                </p></li></ul></div><p>
            Hibernate also distinguishes between:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Immediate fetching</em></span> - an association, collection or
                    attribute is fetched immediately, when the owner is loaded.
                </p></li><li><p>
                    <span class="emphasis"><em>Lazy collection fetching</em></span> - a collection is fetched 
                    when the application invokes an operation upon that collection. (This
                    is the default for collections.)
                </p></li><li><p>
                    <span class="emphasis"><em>"Extra-lazy" collection fetching</em></span> - individual
                    elements of the collection are accessed from the database as needed.
                    Hibernate tries not to fetch the whole collection into memory unless
                    absolutely needed (suitable for very large collections)
                </p></li><li><p>
                    <span class="emphasis"><em>Proxy fetching</em></span> - a single-valued association is 
                    fetched when a method other than the identifier getter is invoked
                    upon the associated object.
                </p></li><li><p>
                    <span class="emphasis"><em>"No-proxy" fetching</em></span> - a single-valued association is 
                    fetched when the instance variable is accessed. Compared to proxy fetching, 
                    this approach is less lazy (the association is fetched even when only the 
                    identifier is accessed) but more transparent, since no proxy is visible to 
                    the application. This approach requires buildtime bytecode instrumentation 
                    and is rarely necessary.
                </p></li><li><p>
                    <span class="emphasis"><em>Lazy attribute fetching</em></span> - an attribute or single
                    valued association is fetched when the instance variable is accessed. 
                    This approach requires buildtime bytecode instrumentation and is rarely 
                    necessary.
                </p></li></ul></div><p>
            We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association
            fetched, and <span class="emphasis"><em>how</em></span> is it fetched (what SQL is used). Don't
            confuse them! We use <tt class="literal">fetch</tt> to tune performance. We may use 
            <tt class="literal">lazy</tt> to define a contract for what data is always available 
            in any detached instance of a particular class.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazy"></a>19.1.1.&nbsp;Working with lazy associations</h3></div></div><div></div></div><p>
                By default, Hibernate3 uses lazy select fetching for collections and lazy proxy
                fetching for single-valued associations. These defaults make sense for almost
                all associations in almost all applications. 
            </p><p>
                <span class="emphasis"><em>Note:</em></span> if you set 
                <tt class="literal">hibernate.default_batch_fetch_size</tt>, Hibernate will use the 
                batch fetch optimization for lazy fetching (this optimization may also be enabled 
                at a more granular level).
            </p><p>
                However, lazy fetching poses one problem that you must be aware of. Access to a 
                lazy association outside of the context of an open Hibernate session will result 
                in an exception. For example:
            </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>
                Since the permissions collection was not initialized when the 
                <tt class="literal">Session</tt> was closed, the collection will not be able to 
                load its state. <span class="emphasis"><em>Hibernate does not support lazy initialization 
                for detached objects</em></span>. The fix is to move the code that reads 
                from the collection to just before the transaction is committed.
            </p><p>
                Alternatively, we could use a non-lazy collection or association, 
                by specifying <tt class="literal">lazy="false"</tt> for the association mapping.
                However, it is intended that lazy initialization be used for almost all 
                collections and associations. If you define too many non-lazy associations 
                in your object model, Hibernate will end up needing to fetch the entire 
                database into memory in every transaction!
            </p><p>
                On the other hand, we often want to choose join fetching (which is non-lazy by 
                nature) instead of select fetching in a particular transaction. We'll now see
                how to customize the fetching strategy. In Hibernate3, the mechanisms for
                choosing a fetch strategy are identical for single-valued associations and
                collections.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-custom"></a>19.1.2.&nbsp;Tuning fetch strategies</h3></div></div><div></div></div><p>
                Select fetching (the default) is extremely vulnerable to N+1 selects problems, 
                so we might want to enable join fetching in the mapping document:
            </p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>
                The <tt class="literal">fetch</tt> strategy defined in the mapping document affects:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                    retrieval via <tt class="literal">get()</tt> or <tt class="literal">load()</tt>
                </p></li><li><p>
                    retrieval that happens implicitly when an association is navigated
                </p></li><li><p>
                    <tt class="literal">Criteria</tt> queries
                </p></li><li><p>
                    HQL queries if <tt class="literal">subselect</tt> fetching is used
                </p></li></ul></div><p>
                No matter what fetching strategy you use, the defined non-lazy graph is guaranteed
                to be loaded into memory. Note that this might result in several immediate selects
                being used to execute a particular HQL query.
            </p><p>
                Usually, we don't use the mapping document to customize fetching. Instead, we
                keep the default behavior, and override it for a particular transaction, using 
                <tt class="literal">left join fetch</tt> in HQL. This tells Hibernate to fetch 
                the association eagerly in the first select, using an outer join. In the
                <tt class="literal">Criteria</tt> query API, you would use
                <tt class="literal">setFetchMode(FetchMode.JOIN)</tt>.
            </p><p>
                If you ever feel like you wish you could change the fetching strategy used by
                <tt class="literal">get()</tt> or <tt class="literal">load()</tt>, simply use a 
                <tt class="literal">Criteria</tt> query, for example:
            </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();</pre><p>
                (This is Hibernate's equivalent of what some ORM solutions call a "fetch plan".)
            </p><p>
                A completely different way to avoid problems with N+1 selects is to use the 
                second-level cache.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-proxies"></a>19.1.3.&nbsp;Single-ended association proxies</h3></div></div><div></div></div><p>
                Lazy fetching for collections is implemented using Hibernate's own implementation
                of persistent collections. However, a different mechanism is needed for lazy
                behavior in single-ended associations. The target entity of the association must
                be proxied. Hibernate implements lazy initializing proxies for persistent objects
                using runtime bytecode enhancement (via the excellent CGLIB library).
            </p><p>
                By default, Hibernate3 generates proxies (at startup) for all persistent classes
                and uses them to enable lazy fetching of <tt class="literal">many-to-one</tt> and
                <tt class="literal">one-to-one</tt> associations.
            </p><p>
                The mapping file may declare an interface to use as the proxy interface for that
                class, with the <tt class="literal">proxy</tt> attribute. By default, Hibernate uses a subclass
                of the class. <span class="emphasis"><em>Note that the proxied class must implement a default constructor
                with at least package visibility. We recommend this constructor for all persistent classes!</em></span>
            </p><p>
                There are some gotchas to be aware of when extending this approach to polymorphic
                classes, eg.
            </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                Firstly, instances of <tt class="literal">Cat</tt> will never be castable to
                <tt class="literal">DomesticCat</tt>, even if the underlying instance is an
                instance of <tt class="literal">DomesticCat</tt>:
            </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>
                Secondly, it is possible to break proxy <tt class="literal">==</tt>.
            </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>
                However, the situation is not quite as bad as it looks. Even though we now have two references
                to different proxy objects, the underlying instance will still be the same object:
            </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>
                Third, you may not use a CGLIB proxy for a <tt class="literal">final</tt> class or a class
                with any <tt class="literal">final</tt> methods.
            </p><p>
                Finally, if your persistent object acquires any resources upon instantiation (eg. in
                initializers or default constructor), then those resources will also be acquired by
                the proxy. The proxy class is an actual subclass of the persistent class.
            </p><p>
                These problems are all due to fundamental limitations in Java's single inheritance model.
                If you wish to avoid these problems your persistent classes must each implement an interface
                that declares its business methods. You should specify these interfaces in the mapping file. eg.
            </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                where <tt class="literal">CatImpl</tt> implements the interface <tt class="literal">Cat</tt> and
                <tt class="literal">DomesticCatImpl</tt> implements the interface <tt class="literal">DomesticCat</tt>. Then
                proxies for instances of <tt class="literal">Cat</tt> and <tt class="literal">DomesticCat</tt> may be returned
                by <tt class="literal">load()</tt> or <tt class="literal">iterate()</tt>. (Note that <tt class="literal">list()</tt>
                does not usually return proxies.)
            </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.iterate("from CatImpl as cat where cat.name='fritz'");
Cat fritz = (Cat) iter.next();</pre><p>
                Relationships are also lazily initialized. This means you must declare any properties to be of
                type <tt class="literal">Cat</tt>, not <tt class="literal">CatImpl</tt>.
            </p><p>
                Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">equals()</tt>, if the persistent class does not override
                        <tt class="literal">equals()</tt>
                    </p></li><li><p>
                        <tt class="literal">hashCode()</tt>, if the persistent class does not override
                        <tt class="literal">hashCode()</tt>
                    </p></li><li><p>
                        The identifier getter method
                    </p></li></ul></div><p>
                Hibernate will detect persistent classes that override <tt class="literal">equals()</tt> or
                <tt class="literal">hashCode()</tt>.
            </p><p>
                By choosing <tt class="literal">lazy="no-proxy"</tt> instead of the default 
                <tt class="literal">lazy="proxy"</tt>, we can avoid the problems associated with typecasting.
                However, we will require buildtime bytecode instrumentation, and all operations
                will result in immediate proxy initialization.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-initialization"></a>19.1.4.&nbsp;Initializing collections and proxies</h3></div></div><div></div></div><p>
                A <tt class="literal">LazyInitializationException</tt> will be thrown by Hibernate if an uninitialized 
                collection or proxy is accessed outside of the scope of the <tt class="literal">Session</tt>, ie. when 
                the entity owning the collection or having the reference to the proxy is in the detached state.
            </p><p>
                Sometimes we need to ensure that a proxy or collection is initialized before closing the
                <tt class="literal">Session</tt>. Of course, we can alway force initialization by calling
                <tt class="literal">cat.getSex()</tt> or <tt class="literal">cat.getKittens().size()</tt>, for example.
                But that is confusing to readers of the code and is not convenient for generic code.
            </p><p>
                The static methods <tt class="literal">Hibernate.initialize()</tt> and <tt class="literal">Hibernate.isInitialized()</tt>
                provide the application with a convenient way of working with lazily initialized collections or
                proxies. <tt class="literal">Hibernate.initialize(cat)</tt> will force the initialization of a proxy,
                <tt class="literal">cat</tt>, as long as its <tt class="literal">Session</tt> is still open.
                <tt class="literal">Hibernate.initialize( cat.getKittens() )</tt> has a similar effect for the collection
                of kittens.
            </p><p>
                Another option is to keep the <tt class="literal">Session</tt> open until all needed
                collections and proxies have been loaded. In some application architectures,
                particularly where the code that accesses data using Hibernate, and the code that
                uses it are in different application layers or different physical processes, it 
                can be a problem to ensure that the <tt class="literal">Session</tt> is open when a 
                collection is initialized. There are two basic ways to deal with this issue:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        In a web-based application, a servlet filter can be used to close the
                        <tt class="literal">Session</tt> only at the very end of a user request, once
                        the rendering of the view is complete (the <span class="emphasis"><em>Open Session in
                        View</em></span> pattern).  Of course, this places heavy demands on the 
                        correctness of the exception handling of your application infrastructure. 
                        It is vitally important that the <tt class="literal">Session</tt> is closed and the 
                        transaction ended before returning to the user, even when an exception occurs 
                        during rendering of the view. See the Hibernate Wiki for examples of this
                        "Open Session in View" pattern.
                    </p></li><li><p>
                        In an application with a separate business tier, the business logic must
                        "prepare" all collections that will be needed by the web tier before
                        returning. This means that the business tier should load all the data and
                        return all the data already initialized to the presentation/web tier that
                        is required for a particular use case. Usually, the application calls
                        <tt class="literal">Hibernate.initialize()</tt> for each collection that will
                        be needed in the web tier (this call must occur before the session is closed)
                        or retrieves the collection eagerly using a Hibernate query with a
                        <tt class="literal">FETCH</tt> clause or a <tt class="literal">FetchMode.JOIN</tt> in
                        <tt class="literal">Criteria</tt>. This is usually easier if you adopt the
                        <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>.
                    </p></li><li><p>
                        You may also attach a previously loaded object to a new <tt class="literal">Session</tt>
                        with <tt class="literal">merge()</tt> or <tt class="literal">lock()</tt> before
                        accessing uninitialized collections (or other proxies). No, Hibernate does not,
                        and certainly <span class="emphasis"><em>should</em></span> not do this automatically, since it 
                        would introduce ad hoc transaction semantics!
                    </p></li></ul></div><p>
                Sometimes you don't want to initialize a large collection, but still need some
                information about it (like its size) or a subset of the data.
            </p><p>
                You can use a collection filter to get the size of a collection without initializing it:
            </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p>
                The <tt class="literal">createFilter()</tt> method is also used to efficiently retrieve subsets
                of a collection without needing to initialize the whole collection:
            </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-batch"></a>19.1.5.&nbsp;Using batch fetching</h3></div></div><div></div></div><p>
                Hibernate can make efficient use of batch fetching, that is, Hibernate can load several uninitialized
                proxies if one proxy is accessed (or collections. Batch fetching is an optimization of the lazy select
                fetching strategy. There are two ways you can tune batch fetching: on the class and the collection level.
            </p><p>
                Batch fetching for classes/entities is easier to understand. Imagine you have the following situation
                at runtime: You have 25 <tt class="literal">Cat</tt> instances loaded in a <tt class="literal">Session</tt>, each
                <tt class="literal">Cat</tt> has a reference to its <tt class="literal">owner</tt>, a <tt class="literal">Person</tt>.
                The <tt class="literal">Person</tt> class is mapped with a proxy, <tt class="literal">lazy="true"</tt>. If you now
                iterate through all cats and call <tt class="literal">getOwner()</tt> on each, Hibernate will by default
                execute 25 <tt class="literal">SELECT</tt> statements, to retrieve the proxied owners. You can tune this
                behavior by specifying a <tt class="literal">batch-size</tt> in the mapping of <tt class="literal">Person</tt>:
            </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>
                Hibernate will now execute only three queries, the pattern is 10, 10, 5.
            </p><p>
                You may also enable batch fetching of collections. For example, if each <tt class="literal">Person</tt> has
                a lazy collection of <tt class="literal">Cat</tt>s, and 10 persons are currently loaded in the
                <tt class="literal">Sesssion</tt>, iterating through all persons will generate 10 <tt class="literal">SELECT</tt>s,
                one for every call to <tt class="literal">getCats()</tt>. If you enable batch fetching for the
                <tt class="literal">cats</tt> collection in the mapping of <tt class="literal">Person</tt>, Hibernate can pre-fetch
                collections:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
                With a <tt class="literal">batch-size</tt> of 8, Hibernate will load 3, 3, 3, 1 collections in four
                <tt class="literal">SELECT</tt>s. Again, the value of the attribute depends on the expected number of
                uninitialized collections in a particular <tt class="literal">Session</tt>.
            </p><p>
                Batch fetching of collections is particularly useful if you have a nested tree of items, ie.
                the typical bill-of-materials pattern. (Although a <span class="emphasis"><em>nested set</em></span> or a
                <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-subselect"></a>19.1.6.&nbsp;Using subselect fetching</h3></div></div><div></div></div><p>
                If one lazy collection or single-valued proxy has to be fetched, Hibernate loads all of
                them, re-running the original query in a subselect. This works in the same way as
                batch-fetching, without the piecemeal loading.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazyproperties"></a>19.1.7.&nbsp;Using lazy property fetching</h3></div></div><div></div></div><p>
                Hibernate3 supports the lazy fetching of individual properties. This optimization technique
                is also known as <span class="emphasis"><em>fetch groups</em></span>. Please note that this is mostly a
                marketing feature, as in practice, optimizing row reads is much more important than
                optimization of column reads. However, only loading some properties of a class might
                be useful in extreme cases, when legacy tables have hundreds of columns and the data model
                can not be improved.
            </p><p>
                To enable lazy property loading, set the <tt class="literal">lazy</tt> attribute on your
                particular property mappings:
            </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class&gt;</pre><p>
                Lazy property loading requires buildtime bytecode instrumentation! If your persistent
                classes are not enhanced, Hibernate will silently ignore lazy property settings and
                fall back to immediate fetching.
            </p><p>
                For bytecode instrumentation, use the following Ant task:
            </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;</pre><p>
                A different (better?) way to avoid unnecessary column reads, at least for
                read-only transactions is to use the projection features of HQL or Criteria
                queries. This avoids the need for buildtime bytecode processing and is
                certainly a prefered solution.
            </p><p>
                You may force the usual eager fetching of properties using <tt class="literal">fetch all
                properties</tt> in HQL.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>19.2.&nbsp;The Second Level Cache</h2></div></div><div></div></div><p>
            A Hibernate <tt class="literal">Session</tt> is a transaction-level cache of persistent data. It is
            possible to configure a cluster or JVM-level (<tt class="literal">SessionFactory</tt>-level) cache on 
            a class-by-class and collection-by-collection basis. You may even plug in a clustered cache. Be 
            careful. Caches are never aware of changes made to the persistent store by another application 
            (though they may be configured to regularly expire cached data).
        </p><p>
            You have the option to tell Hibernate which caching implementation to use by
            specifying the name of a class that implements <tt class="literal">org.hibernate.cache.CacheProvider</tt>
            using the property <tt class="literal">hibernate.cache.provider_class</tt>.  Hibernate
            comes bundled with a number of built-in integrations with open-source cache providers
            (listed below); additionally, you could implement your own and plug it in as
            outlined above.  Note that versions prior to 3.2 defaulted to use EhCache as the
            default cache provider; that is no longer the case as of 3.2.
        </p><div class="table"><a name="cacheproviders"></a><p class="title"><b>Table&nbsp;19.1.&nbsp;Cache Providers</b></p><table summary="Cache Providers" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><tt class="literal">org.hibernate.cache.HashtableCacheProvider</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><tt class="literal">org.hibernate.cache.EhCacheProvider</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><tt class="literal">org.hibernate.cache.OSCacheProvider</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><tt class="literal">org.hibernate.cache.SwarmCacheProvider</tt></td><td align="left">clustered (ip multicast)</td><td align="left">yes (clustered invalidation)</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left"><tt class="literal">org.hibernate.cache.TreeCacheProvider</tt></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication)</td><td align="left">yes (clock sync req.)</td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>19.2.1.&nbsp;Cache mappings</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;cache&gt;</tt> element of a class or collection mapping has the
                following form:
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span class="co">(1)</span>
    region="RegionName"                                              <span class="co">(2)</span>
    include="all|non-lazy"                                           <span class="co">(3)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> (required) specifies the caching strategy:
                            <tt class="literal">transactional</tt>,
                            <tt class="literal">read-write</tt>,
                            <tt class="literal">nonstrict-read-write</tt> or
                            <tt class="literal">read-only</tt>
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">region</tt> (optional, defaults to the class or
                            collection role name) specifies the name of the second level cache 
                            region
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">include</tt> (optional, defaults to <tt class="literal">all</tt>) 
                            <tt class="literal">non-lazy</tt> specifies that properties of the entity mapped
                            with <tt class="literal">lazy="true"</tt> may not be cached when attribute-level
                            lazy fetching is enabled
                        </p></td></tr></table></div></div><p>
                Alternatively (preferrably?), you may specify <tt class="literal">&lt;class-cache&gt;</tt> and 
                <tt class="literal">&lt;collection-cache&gt;</tt> elements in <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                The <tt class="literal">usage</tt> attribute specifies a <span class="emphasis"><em>cache concurrency strategy</em></span>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>19.2.2.&nbsp;Strategy: read only</h3></div></div><div></div></div><p>
                If your application needs to read but never modify instances of a persistent class, a 
                <tt class="literal">read-only</tt> cache may be used. This is the simplest and best performing
                strategy. It's even perfectly safe for use in a cluster.
            </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>19.2.3.&nbsp;Strategy: read/write</h3></div></div><div></div></div><p>
                If the application needs to update data, a <tt class="literal">read-write</tt> cache might be appropriate. 
                This cache strategy should never be used if serializable transaction isolation level is required. 
                If the cache is used in a JTA environment, you must specify the property 
                <tt class="literal">hibernate.transaction.manager_lookup_class</tt>, naming a strategy for obtaining the 
                JTA <tt class="literal">TransactionManager</tt>. In other environments, you should ensure that the transaction 
                is completed when <tt class="literal">Session.close()</tt> or <tt class="literal">Session.disconnect()</tt> is called. 
                If you wish to use this strategy in a cluster, you should ensure that the underlying cache implementation 
                supports locking. The built-in cache providers do <span class="emphasis"><em>not</em></span>.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>19.2.4.&nbsp;Strategy: nonstrict read/write</h3></div></div><div></div></div><p>
                If the application only occasionally needs to update data (ie. if it is extremely unlikely that two 
                transactions would try to update the same item simultaneously) and strict transaction isolation is
                not required, a <tt class="literal">nonstrict-read-write</tt> cache might be appropriate. If the cache is 
                used in a JTA environment, you must specify <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
                In other environments, you should ensure that the transaction is completed when 
                <tt class="literal">Session.close()</tt> or <tt class="literal">Session.disconnect()</tt> is called.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-transactional"></a>19.2.5.&nbsp;Strategy: transactional</h3></div></div><div></div></div><p>
                The <tt class="literal">transactional</tt> cache strategy provides support for fully transactional cache
                providers such as JBoss TreeCache. Such a cache may only be used in a JTA environment and you must 
                specify <tt class="literal">hibernate.transaction.manager_lookup_class</tt>. 
            </p></div><p>
            None of the cache providers support all of the cache concurrency strategies. The following table shows
            which providers are compatible with which concurrency strategies.
        </p><div class="table"><a name="d0e14755"></a><p class="title"><b>Table&nbsp;19.2.&nbsp;Cache Concurrency Strategy Support</b></p><table summary="Cache Concurrency Strategy Support" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">JBoss TreeCache</td><td align="left">yes</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td><td align="left">yes</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>19.3.&nbsp;Managing the caches</h2></div></div><div></div></div><p>
            Whenever you pass an object to <tt class="literal">save()</tt>, <tt class="literal">update()</tt>
            or <tt class="literal">saveOrUpdate()</tt> and whenever you retrieve an object using 
            <tt class="literal">load()</tt>, <tt class="literal">get()</tt>, <tt class="literal">list()</tt>, 
            <tt class="literal">iterate()</tt> or <tt class="literal">scroll()</tt>, that object is added 
            to the internal cache of the <tt class="literal">Session</tt>. 
        </p><p>
            When <tt class="literal">flush()</tt> is subsequently called, the state of that object will 
            be synchronized with the database. If you do not want this synchronization to occur or 
            if you are processing a huge number of objects and need to manage memory efficiently, 
            the <tt class="literal">evict()</tt> method may be used to remove the object and its collections 
            from the first-level cache.
        </p><pre class="programlisting">ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p>
            The <tt class="literal">Session</tt> also provides a <tt class="literal">contains()</tt> method to determine 
            if an instance belongs to the session cache.
        </p><p>
            To completely evict all objects from the session cache, call <tt class="literal">Session.clear()</tt>
        </p><p>
            For the second-level cache, there are methods defined on <tt class="literal">SessionFactory</tt> for 
            evicting the cached state of an instance, entire class, collection instance or entire collection 
            role.
        </p><pre class="programlisting">sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections</pre><p>
            The <tt class="literal">CacheMode</tt> controls how a particular session interacts with the second-level
            cache.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">CacheMode.NORMAL</tt> - read items from and write items to the second-level cache
        </p></li><li><p>
            <tt class="literal">CacheMode.GET</tt> - read items from the second-level cache, but don't write to
            the second-level cache except when updating data
        </p></li><li><p>
            <tt class="literal">CacheMode.PUT</tt> - write items to the second-level cache, but don't read from
            the second-level cache
        </p></li><li><p>
            <tt class="literal">CacheMode.REFRESH</tt> - write items to the second-level cache, but don't read from
            the second-level cache, bypass the effect of <tt class="literal">hibernate.cache.use_minimal_puts</tt>, forcing
            a refresh of the second-level cache for all items read from the database
        </p></li></ul></div><p>
            To browse the contents of a second-level or query cache region, use the <tt class="literal">Statistics</tt>
            API:
        </p><pre class="programlisting">Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();</pre><p>
            You'll need to enable statistics, and, optionally, force Hibernate to keep the cache entries in a
            more human-understandable format:
        </p><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>19.4.&nbsp;The Query Cache</h2></div></div><div></div></div><p>
            Query result sets may also be cached. This is only useful for queries that are run
            frequently with the same parameters. To use the query cache you must first enable it:
        </p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>
            This setting causes the creation of two new cache regions - one holding cached query 
            result sets (<tt class="literal">org.hibernate.cache.StandardQueryCache</tt>), the other 
            holding timestamps of the most recent updates to queryable tables 
            (<tt class="literal">org.hibernate.cache.UpdateTimestampsCache</tt>). Note that the query
            cache does not cache the state of the actual entities in the result set; it caches 
            only identifier values and results of value type. So the query cache should always be
            used in conjunction with the second-level cache.
        </p><p>
            Most queries do not benefit from caching, so by default queries are not cached. To
            enable caching, call <tt class="literal">Query.setCacheable(true)</tt>. This call allows
            the query to look for existing cache results or add its results to the cache when
            it is executed.
        </p><p>
            If you require fine-grained control over query cache expiration policies, you may
            specify a named cache region for a particular query by calling 
            <tt class="literal">Query.setCacheRegion()</tt>.
        </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>
            If the query should force a refresh of its query cache region, you should call
            <tt class="literal">Query.setCacheMode(CacheMode.REFRESH)</tt>. This is particularly useful 
            in cases where underlying data may have been updated via a separate process (i.e., 
            not modified through Hibernate) and allows the application to selectively refresh 
            particular query result sets. This is a more efficient alternative to eviction of 
            a query cache region via <tt class="literal">SessionFactory.evictQueries()</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>19.5.&nbsp;Understanding Collection performance</h2></div></div><div></div></div><p>
            We've already spent quite some time talking about collections.
            In this section we will highlight a couple more issues about
            how collections behave at runtime.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>19.5.1.&nbsp;Taxonomy</h3></div></div><div></div></div><p>Hibernate defines three basic kinds of collections:</p><div class="itemizedlist"><ul type="disc"><li><p>collections of values</p></li><li><p>one to many associations</p></li><li><p>many to many associations</p></li></ul></div><p>
                This classification distinguishes the various table and foreign key
                relationships but does not tell us quite everything we need to know
                about the relational model. To fully understand the relational structure
                and performance characteristics, we must also consider the structure of
                the primary key that is used by Hibernate to update or delete collection
                rows. This suggests the following classification:
            </p><div class="itemizedlist"><ul type="disc"><li><p>indexed collections</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>
                All indexed collections (maps, lists, arrays) have a primary key consisting
                of the <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt>
                columns. In this case collection updates are usually extremely efficient -
                the primary key may be efficiently indexed and a particular row may be efficiently
                located when Hibernate tries to update or delete it.
            </p><p>
                Sets have a primary key consisting of <tt class="literal">&lt;key&gt;</tt> and element
                columns. This may be less efficient for some types of collection element, particularly
                composite elements or large text or binary fields; the database may not be able to index
                a complex primary key as efficently.  On the other hand, for one to many or many to many
                associations, particularly in the case of synthetic identifiers, it is likely to be just
                as efficient. (Side-note: if you want <tt class="literal">SchemaExport</tt> to actually create
                the primary key of a <tt class="literal">&lt;set&gt;</tt> for you, you must declare all columns
                as <tt class="literal">not-null="true"</tt>.)
            </p><p>
                <tt class="literal">&lt;idbag&gt;</tt> mappings define a surrogate key, so they are
                always very efficient to update. In fact, they are the best case.
            </p><p>
                Bags are the worst case. Since a bag permits duplicate element values and has no
                index column, no primary key may be defined. Hibernate has no way of distinguishing
                between duplicate rows. Hibernate resolves this problem by completely removing
                (in a single <tt class="literal">DELETE</tt>) and recreating the collection whenever it
                changes. This might be very inefficient.
            </p><p>
                Note that for a one-to-many association, the "primary key" may not be the physical
                primary key of the database table - but even in this case, the above classification
                is still useful. (It still reflects how Hibernate "locates" individual rows of the
                collection.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>19.5.2.&nbsp;Lists, maps, idbags and sets are the most efficient collections to update</h3></div></div><div></div></div><p>
                From the discussion above, it should be clear that indexed collections
                and (usually) sets allow the most efficient operation in terms of adding,
                removing and updating elements.
            </p><p>
                There is, arguably, one more advantage that indexed collections have over sets for
                many to many associations or collections of values. Because of the structure of a
                <tt class="literal">Set</tt>, Hibernate doesn't ever <tt class="literal">UPDATE</tt> a row when
                an element is "changed". Changes to a <tt class="literal">Set</tt> always work via
                <tt class="literal">INSERT</tt> and <tt class="literal">DELETE</tt> (of individual rows). Once
                again, this consideration does not apply to one to many associations.
            </p><p>
                After observing that arrays cannot be lazy, we would conclude that lists, maps and 
                idbags are the most performant (non-inverse) collection types, with sets not far 
                behind. Sets are expected to be the most common kind of collection in Hibernate 
                applications. This is because the "set" semantics are most natural in the relational
                model.
            </p><p>
                However, in well-designed Hibernate domain models, we usually see that most collections
                are in fact one-to-many associations with <tt class="literal">inverse="true"</tt>. For these
                associations, the update is handled by the many-to-one end of the association, and so
                considerations of collection update performance simply do not apply.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>19.5.3.&nbsp;Bags and lists are the most efficient inverse collections</h3></div></div><div></div></div><p>
                Just before you ditch bags forever, there is a particular case in which bags (and also lists)
                are much more performant than sets. For a collection with <tt class="literal">inverse="true"</tt>
                (the standard bidirectional one-to-many relationship idiom, for example) we can add elements
                to a bag or list without needing to initialize (fetch) the bag elements! This is because
                <tt class="literal">Collection.add()</tt> or <tt class="literal">Collection.addAll()</tt> must always
                return true for a bag or <tt class="literal">List</tt> (unlike a <tt class="literal">Set</tt>). This can
                make the following common code much faster.
            </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);  //no need to fetch the collection!
sess.flush();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>19.5.4.&nbsp;One shot delete</h3></div></div><div></div></div><p>
                Occasionally, deleting collection elements one by one can be extremely inefficient. Hibernate
                isn't completely stupid, so it knows not to do that in the case of an newly-empty collection
                (if you called <tt class="literal">list.clear()</tt>, for example). In this case, Hibernate will
                issue a single <tt class="literal">DELETE</tt> and we are done!
            </p><p>
                Suppose we add a single element to a collection of size twenty and then remove two elements.
                Hibernate will issue one <tt class="literal">INSERT</tt> statement and two <tt class="literal">DELETE</tt>
                statements (unless the collection is a bag). This is certainly desirable.
            </p><p>
                However, suppose that we remove eighteen elements, leaving two and then add thee new elements.
                There are two possible ways to proceed
            </p><div class="itemizedlist"><ul type="disc"><li><p>delete eighteen rows one by one and then insert three rows</p></li><li><p>remove the whole collection (in one SQL <tt class="literal">DELETE</tt>) and insert
                all five current elements (one by one)</p></li></ul></div><p>
                Hibernate isn't smart enough to know that the second option is probably quicker in this case.
                (And it would probably be undesirable for Hibernate to be that smart; such behaviour might
                confuse database triggers, etc.)
            </p><p>
                Fortunately, you can force this behaviour (ie. the second strategy) at any time by discarding
                (ie. dereferencing) the original collection and returning a newly instantiated collection with
                all the current elements. This can be very useful and powerful from time to time.
            </p><p>
                Of course, one-shot-delete does not apply to collections mapped <tt class="literal">inverse="true"</tt>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-monitoring"></a>19.6.&nbsp;Monitoring performance</h2></div></div><div></div></div><p>
            Optimization is not much use without monitoring and access to performance numbers.
            Hibernate provides a full range of figures about its internal operations.
            Statistics in Hibernate are available per <tt class="literal">SessionFactory</tt>.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-monitoring-sf"></a>19.6.1.&nbsp;Monitoring a SessionFactory</h3></div></div><div></div></div><p>
                You can access <tt class="literal">SessionFactory</tt> metrics in two ways.
                Your first option is to call <tt class="literal">sessionFactory.getStatistics()</tt> and
                read or display the <tt class="literal">Statistics</tt> yourself.
            </p><p>
                Hibernate can also use JMX to publish metrics if you enable the
                <tt class="literal">StatisticsService</tt> MBean. You may enable a single MBean for all your
                <tt class="literal">SessionFactory</tt> or one per factory. See the following code for
                minimalistic configuration examples:
            </p><pre class="programlisting">// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server</pre><pre class="programlisting">// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server</pre><p>
                TODO: This doesn't make sense: In the first case, we retrieve and use the MBean directly. In the second one, we must give
                the JNDI name in which the session factory is held before using it. Use
                <tt class="literal">hibernateStatsBean.setSessionFactoryJNDIName("my/JNDI/Name")</tt>
            </p><p>
                You can (de)activate the monitoring for a <tt class="literal">SessionFactory</tt>
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        at configuration time, set <tt class="literal">hibernate.generate_statistics</tt> to <tt class="literal">false</tt>
                    </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                        at runtime: <tt class="literal">sf.getStatistics().setStatisticsEnabled(true)</tt>
                        or <tt class="literal">hibernateStatsBean.setStatisticsEnabled(true)</tt>
                    </p></li></ul></div><p>
                Statistics can be reset programatically using the <tt class="literal">clear()</tt> method.
                A summary can be sent to a logger (info level) using the <tt class="literal">logSummary()</tt>
                method.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-monitoring-metrics"></a>19.6.2.&nbsp;Metrics</h3></div></div><div></div></div><p>
                Hibernate provides a number of metrics, from very basic to the specialized information
                only relevant in certain scenarios. All available counters are described in the
                <tt class="literal">Statistics</tt> interface API, in three categories:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        Metrics related to the general <tt class="literal">Session</tt> usage, such as
                        number of open sessions, retrieved JDBC connections, etc.
                    </p></li><li><p>
                        Metrics related to he entities, collections, queries, and caches as a
                        whole (aka global metrics),
                    </p></li><li><p>
                        Detailed metrics related to a particular entity, collection, query or
                        cache region.
                    </p></li></ul></div><p>
                For exampl,e you can check the cache hit, miss, and put ratio of entities, collections
                and queries, and the average time a query needs. Beware that the number of milliseconds
                is subject to approximation in Java. Hibernate is tied to the JVM precision, on some
                platforms this might even only be accurate to 10 seconds.
            </p><p>
                Simple getters are used to access the global metrics (i.e. not tied to a particular entity,
                collection, cache region, etc.). You can access the metrics of a particular entity, collection
                or cache region through its name, and through its HQL or SQL representation for queries. Please
                refer to the <tt class="literal">Statistics</tt>, <tt class="literal">EntityStatistics</tt>,
                <tt class="literal">CollectionStatistics</tt>, <tt class="literal">SecondLevelCacheStatistics</tt>,
                and <tt class="literal">QueryStatistics</tt> API Javadoc for more information. The following
                code shows a simple example:
            </p><pre class="programlisting">Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );</pre><p>
                To work on all entities, collections, queries and region caches, you can retrieve
                the list of names of entities, collections, queries and region caches with the
                following methods: <tt class="literal">getQueries()</tt>, <tt class="literal">getEntityNames()</tt>,
                <tt class="literal">getCollectionRoleNames()</tt>, and
                <tt class="literal">getSecondLevelCacheRegionNames()</tt>.
            </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xml.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="toolsetguide.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;18.&nbsp;XML Mapping&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;20.&nbsp;Toolset Guide</td></tr></table></div></body></html>