<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;Configuration</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"><link rel="previous" href="architecture.html" title="Chapter&nbsp;2.&nbsp;Architecture"><link rel="next" href="persistent-classes.html" title="Chapter&nbsp;4.&nbsp;Persistent Classes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;3.&nbsp;Configuration</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="architecture.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="persistent-classes.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Chapter&nbsp;3.&nbsp;Configuration</h2></div></div><div></div></div><p>
        Because Hibernate is designed to operate in many different environments, there
        are a large number of configuration parameters. Fortunately, most have sensible
        default values and Hibernate is distributed with an example 
        <tt class="literal">hibernate.properties</tt> file in <tt class="literal">etc/</tt> that shows
        the various options. Just put the example file in your classpath and customize it.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Programmatic configuration</h2></div></div><div></div></div><p>
            An instance of <tt class="literal">org.hibernate.cfg.Configuration</tt>
            represents an entire set of mappings of an application's Java types to an
            SQL database. The <tt class="literal">Configuration</tt> is used to build an
            (immutable) <tt class="literal">SessionFactory</tt>. The mappings are compiled
            from various XML mapping files.
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by instantiating 
            it directly and specifying XML mapping documents. If the mapping files are
            in the classpath, use <tt class="literal">addResource()</tt>:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");</pre><p>
            An alternative (sometimes better) way is to specify the mapped class, and
            let Hibernate find the mapping document for you:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>
            Then Hibernate will look for mapping files named
            <tt class="literal">/org/hibernate/auction/Item.hbm.xml</tt> and
            <tt class="literal">/org/hibernate/auction/Bid.hbm.xml</tt> in the classpath.
            This approach eliminates any hardcoded filenames.
        </p><p>
            A <tt class="literal">Configuration</tt> also allows you to specify configuration
            properties:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");</pre><p>
            This is not the only way to pass configuration properties to Hibernate. 
            The various options include:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Pass an instance of <tt class="literal">java.util.Properties</tt> to
                    <tt class="literal">Configuration.setProperties()</tt>.
                </p></li><li><p>
                    Place <tt class="literal">hibernate.properties</tt> in a root directory 
                    of the classpath.
                </p></li><li><p>
                    Set <tt class="literal">System</tt> properties using
                    <tt class="literal">java -Dproperty=value</tt>.
                </p></li><li><p>
                    Include <tt class="literal">&lt;property&gt;</tt> elements in
                    <tt class="literal">hibernate.cfg.xml</tt> (discussed later).
                </p></li></ol></div><p>
            <tt class="literal">hibernate.properties</tt> is the easiest approach if you
            want to get started quickly.
        </p><p>
            The <tt class="literal">Configuration</tt> is intended as a startup-time object, 
            to be discarded once a <tt class="literal">SessionFactory</tt> is created.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Obtaining a SessionFactory</h2></div></div><div></div></div><p>
            When all mappings have been parsed by the <tt class="literal">Configuration</tt>, 
            the application must obtain a factory for <tt class="literal">Session</tt> instances. 
            This factory is intended to be shared by all application threads:
        </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>
            Hibernate does allow your application to instantiate more than one
            <tt class="literal">SessionFactory</tt>. This is useful if you are using more than 
            one database.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.3.&nbsp;JDBC connections</h2></div></div><div></div></div><p>
            Usually, you want to have the <tt class="literal">SessionFactory</tt> create and pool JDBC 
            connections for you. If you take this approach, opening a <tt class="literal">Session</tt> 
            is as simple as:
        </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session</pre><p>
            As soon as you do something that requires access to the database, a JDBC connection
            will be obtained from the pool.
        </p><p>
            For this to work, we need to pass some JDBC connection properties to Hibernate.
            All Hibernate property names and semantics are defined on the class 
            <tt class="literal">org.hibernate.cfg.Environment</tt>. We will now describe the most
            important settings for JDBC connection configuration.
        </p><p>
            Hibernate will obtain (and pool) connections using <tt class="literal">java.sql.DriverManager</tt> 
            if you set the following properties:
        </p><div class="table"><a name="d0e1632"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Hibernate JDBC Properties</b></p><table summary="Hibernate JDBC Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td><span class="emphasis"><em>jdbc driver class</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td><span class="emphasis"><em>jdbc URL</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span></td></tr><tr><td><tt class="literal">hibernate.connection.pool_size</tt></td><td><span class="emphasis"><em>maximum number of pooled connections</em></span></td></tr></tbody></table></div><p>
            Hibernate's own connection pooling algorithm is however quite rudimentary. 
            It is intended to help you get started and is <span class="emphasis"><em>not intended for use 
            in a production system</em></span> or even for performance testing. You should
            use a third party pool for best performance and stability. Just replace the 
            <tt class="literal">hibernate.connection.pool_size</tt> property with connection 
            pool specific settings. This will turn off Hibernate's internal pool. For
            example, you might like to use C3P0.
        </p><p>
            C3P0 is an open source JDBC connection pool distributed along with 
            Hibernate in the <tt class="literal">lib</tt> directory. Hibernate will use its
            <tt class="literal">C3P0ConnectionProvider</tt> for connection pooling if you set 
            <tt class="literal">hibernate.c3p0.*</tt> properties. If you'd like to use Proxool
            refer to the packaged <tt class="literal">hibernate.properties</tt> and the Hibernate
            web site for more information.
        </p><p>
            Here is an example <tt class="literal">hibernate.properties</tt> file for C3P0:
        </p><a name="c3p0-configuration"></a><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>
            For use inside an application server, you should almost always configure 
            Hibernate to obtain connections from an application server  
            <tt class="literal">Datasource</tt> registered in JNDI. You'll need to set at
            least one of the following properties:
        </p><div class="table"><a name="d0e1714"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Hibernate Datasource Properties</b></p><table summary="Hibernate Datasource Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Propery name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.datasource</tt></td><td><span class="emphasis"><em>datasource JNDI name</em></span></td></tr><tr><td><tt class="literal">hibernate.jndi.url</tt></td><td><span class="emphasis"><em>URL of the JNDI provider</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.jndi.class</tt></td><td><span class="emphasis"><em>class of the JNDI <tt class="literal">InitialContextFactory</tt></em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td><span class="emphasis"><em>database user</em></span> (optional)
                </td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td><span class="emphasis"><em>database user password</em></span> (optional)
                </td></tr></tbody></table></div><p>
            Here's an example <tt class="literal">hibernate.properties</tt> file for an
            application server provided JNDI datasource:
        </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>
            JDBC connections obtained from a JNDI datasource will automatically participate
            in the container-managed transactions of the application server.
        </p><p>
            Arbitrary connection properties may be given by prepending
            "<tt class="literal">hibernate.connnection</tt>" to the property name. For example, you
            may specify a <tt class="literal">charSet</tt> using <tt class="literal">hibernate.connection.charSet</tt>.
        </p><p>
            You may define your own plugin strategy for obtaining JDBC connections by implementing the
            interface <tt class="literal">org.hibernate.connection.ConnectionProvider</tt>. You may select
            a custom implementation by setting <tt class="literal">hibernate.connection.provider_class</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.4.&nbsp;Optional configuration properties</h2></div></div><div></div></div><p>
            There are a number of other properties that control the behaviour of Hibernate
            at runtime. All are optional and have reasonable default values.
        </p><p>
        	<span class="emphasis"><em>Warning: some of these properties are "system-level" only.</em></span>
            System-level properties can be set only via <tt class="literal">java -Dproperty=value</tt> or
            <tt class="literal">hibernate.properties</tt>. They may <span class="emphasis"><em>not</em></span> be set by
            the other techniques described above.
        </p><div class="table"><a name="configuration-optional-properties"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Hibernate Configuration Properties</b></p><table summary="Hibernate Configuration Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.dialect</tt></td><td>
                            The classname of a Hibernate <tt class="literal">Dialect</tt> which 
                            allows Hibernate to generate SQL optimized for a particular
                            relational database.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">full.classname.of.Dialect</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.show_sql</tt></td><td>
                            Write all SQL statements to console. This is an alternative
                            to setting the log category <tt class="literal">org.hibernate.SQL</tt>
                            to <tt class="literal">debug</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.format_sql</tt></td><td>
                            Pretty print the SQL in the log and console.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_schema</tt></td><td>
                            Qualify unqualified tablenames with the given schema/tablespace
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">SCHEMA_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_catalog</tt></td><td>
                            Qualify unqualified tablenames with the given catalog
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">CATALOG_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.session_factory_name</tt></td><td>
                            The <tt class="literal">SessionFactory</tt> will be automatically
                            bound to this name in JNDI after it has been created.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.max_fetch_depth</tt></td><td>
                            Set a maximum "depth" for the outer join fetch tree
                            for single-ended associations (one-to-one, many-to-one).
                            A <tt class="literal">0</tt> disables default outer join fetching.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values between <tt class="literal">0</tt> and 
                                <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_batch_fetch_size</tt></td><td>
                            Set a default size for Hibernate batch fetching of associations.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values <tt class="literal">4</tt>, <tt class="literal">8</tt>, 
                                <tt class="literal">16</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.default_entity_mode</tt></td><td>
                            Set a default mode for entity representation for all sessions
                            opened from this <tt class="literal">SessionFactory</tt><p>
                                <tt class="literal">dynamic-map</tt>, <tt class="literal">dom4j</tt>,
                                <tt class="literal">pojo</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.order_updates</tt></td><td>
                            Force Hibernate to order SQL updates by the primary key value
                            of the items being updated. This will result in fewer transaction
                            deadlocks in highly concurrent systems.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.generate_statistics</tt></td><td>
                            If enabled, Hibernate will collect statistics useful for
                            performance tuning.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_identifer_rollback</tt></td><td>
                            If enabled, generated identifier properties will be
                            reset to default values when objects are deleted.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.use_sql_comments</tt></td><td>
                            If turned on, Hibernate will generate comments inside the SQL, for
                            easier debugging, defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-jdbc-properties"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Hibernate JDBC and Connection Properties</b></p><table summary="Hibernate JDBC and Connection Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.jdbc.fetch_size</tt></td><td>
                            A non-zero value determines the JDBC fetch size (calls
                            <tt class="literal">Statement.setFetchSize()</tt>).
                        </td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_size</tt></td><td>
                            A non-zero value enables use of JDBC2 batch updates by Hibernate.
                            <p>
                                <span class="strong">eg.</span>
                                recommended values between <tt class="literal">5</tt> and <tt class="literal">30</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.batch_versioned_data</tt></td><td>
                            Set this property to <tt class="literal">true</tt> if your JDBC driver returns
                            correct row counts from <tt class="literal">executeBatch()</tt> (it is usually
                            safe to turn this option on). Hibernate will then use batched DML for
                            automatically versioned data. Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.factory_class</tt></td><td>
                            Select a custom <tt class="literal">Batcher</tt>. Most applications
                            will not need this configuration property.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.Batcher</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_scrollable_resultset</tt></td><td>
                            Enables use of JDBC2 scrollable resultsets by Hibernate.
                            This property is only necessary when using user supplied
                            JDBC connections, Hibernate uses connection metadata otherwise.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_streams_for_binary</tt></td><td>
                            Use streams when writing/reading <tt class="literal">binary</tt>
                            or <tt class="literal">serializable</tt> types to/from JDBC
                            (system-level property).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.jdbc.use_get_generated_keys</tt></td><td>
                            Enable use of JDBC3 <tt class="literal">PreparedStatement.getGeneratedKeys()</tt>
                            to retrieve natively generated keys after insert. Requires JDBC3+ driver
                            and JRE1.4+, set to false if your driver has problems with the Hibernate
                            identifier generators. By default, tries to determine the driver capabilites
                            using connection metadata.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">ConnectionProvider</tt> which provides
                            JDBC connections to Hibernate.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.ConnectionProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.isolation</tt></td><td>
                        Set the JDBC transaction isolation level. Check
                        <tt class="literal">java.sql.Connection</tt> for meaningful values but
                        note that most databases do not support all isolation levels.
                        <p>
                            <span class="strong">eg.</span> 
                            <tt class="literal">1, 2, 4, 8</tt>
                        </p></td></tr><tr><td><tt class="literal">hibernate.connection.autocommit</tt></td><td>
                            Enables autocommit for JDBC pooled connections (not recommended).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.release_mode</tt></td><td>
                            Specify when Hibernate should release JDBC connections. By default, 
                            a JDBC connection is held until the session is explicitly closed or
                            disconnected. For an application server JTA datasource, you should use
                            <tt class="literal">after_statement</tt> to aggressively release connections
                            after every JDBC call. For a non-JTA connection, it often makes sense to
                            release the connection at the end of each transaction, by using
                            <tt class="literal">after_transaction</tt>. <tt class="literal">auto</tt> will
                            choose <tt class="literal">after_statement</tt> for the JTA and CMT transaction
                            strategies and <tt class="literal">after_transaction</tt> for the JDBC 
                            transaction strategy.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">auto</tt> (default) | <tt class="literal">on_close</tt> |
                                <tt class="literal">after_transaction</tt> | <tt class="literal">after_statement</tt>
                            </p><p>
                                Note that this setting only affects <tt class="literal">Session</tt>s returned from
                                <tt class="literal">SessionFactory.openSession</tt>.  For <tt class="literal">Session</tt>s
                                obtained through <tt class="literal">SessionFactory.getCurrentSession</tt>, the
                                <tt class="literal">CurrentSessionContext</tt> implementation configured for use
                                controls the connection release mode for those <tt class="literal">Session</tt>s.
                                See <a href="architecture.html#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a>
                            </p></td></tr><tr><td><tt class="literal">hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                        Pass the JDBC property <tt class="literal">propertyName</tt>
                        to <tt class="literal">DriverManager.getConnection()</tt>.
                    </td></tr><tr><td><tt class="literal">hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span></tt></td><td>
                            Pass the property <tt class="literal">propertyName</tt> to
                            the JNDI <tt class="literal">InitialContextFactory</tt>.
                        </td></tr></tbody></table></div><div class="table"><a name="configuration-cache-properties"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;Hibernate Cache Properties</b></p><table summary="Hibernate Cache Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.cache.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">CacheProvider</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.CacheProvider</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_minimal_puts</tt></td><td>
                            Optimize second-level cache operation to minimize writes, at the
                            cost of more frequent reads. This setting is most useful for 
                            clustered caches and, in Hibernate3, is enabled by default for
                            clustered cache implementations.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_query_cache</tt></td><td>
                            Enable the query cache, individual queries still have to be set cachable.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_second_level_cache</tt></td><td>
                            May be used to completely disable the second level cache, which is enabled
                            by default for classes which specify a <tt class="literal">&lt;cache&gt;</tt>
                            mapping.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true|false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.query_cache_factory</tt></td><td>
                            The classname of a custom <tt class="literal">QueryCache</tt> interface,
                            defaults to the built-in <tt class="literal">StandardQueryCache</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.QueryCache</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.region_prefix</tt></td><td>
                            A prefix to use for second-level cache region names.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">prefix</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cache.use_structured_entries</tt></td><td>
                            Forces Hibernate to store data in the second-level cache
                            in a more human-friendly format.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true|false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-transaction-properties"></a><p class="title"><b>Table&nbsp;3.6.&nbsp;Hibernate Transaction Properties</b></p><table summary="Hibernate Transaction Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.transaction.factory_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionFactory</tt>
                            to use with Hibernate <tt class="literal">Transaction</tt> API
                            (defaults to <tt class="literal">JDBCTransactionFactory</tt>).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">jta.UserTransaction</tt></td><td>
                            A JNDI name used by <tt class="literal">JTATransactionFactory</tt> to
                            obtain the JTA <tt class="literal">UserTransaction</tt> from the
                            application server.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">jndi/composite/name</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.manager_lookup_class</tt></td><td>
                            The classname of a <tt class="literal">TransactionManagerLookup</tt>
                            - required when JVM-level caching is enabled or when using hilo 
                            generator in a JTA environment.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionManagerLookup</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.flush_before_completion</tt></td><td>
                            If enabled, the session will be automatically flushed during the
                            before completion phase of the transaction. Built-in and
                            automatic session context management is preferred, see
                            <a href="architecture.html#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.transaction.auto_close_session</tt></td><td>
                            If enabled, the session will be automatically closed during the
                            after completion phase of the transaction. Built-in and
                            utomatic session context management is preferred, see
                            <a href="architecture.html#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="table"><a name="configuration-misc-properties"></a><p class="title"><b>Table&nbsp;3.7.&nbsp;Miscellaneous Properties</b></p><table summary="Miscellaneous Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.current_session_context_class</tt></td><td>
                            Supply a (custom) strategy for the scoping of the "current"
                            <tt class="literal">Session</tt>. See
                            <a href="architecture.html#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a> for more
                            information about the built-in strategies.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">jta</tt> | <tt class="literal">thread</tt> |
                                <tt class="literal">managed</tt> | <tt class="literal">custom.Class</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.factory_class</tt></td><td>
                            Chooses the HQL parser implementation.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">org.hibernate.hql.ast.ASTQueryTranslatorFactory</tt> or
                                <tt class="literal">org.hibernate.hql.classic.ClassicQueryTranslatorFactory</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.query.substitutions</tt></td><td>
                            Mapping from tokens in Hibernate queries to SQL tokens
                            (tokens might be function or literal names, for example).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.hbm2ddl.auto</tt></td><td>
                            Automatically validate or export schema DDL to the database 
                            when the <tt class="literal">SessionFactory</tt> is created. With
                            <tt class="literal">create-drop</tt>, the database schema will be 
                            dropped when the <tt class="literal">SessionFactory</tt> is closed 
                            explicitly.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">validate</tt> | <tt class="literal">update</tt> | 
                                <tt class="literal">create</tt> | <tt class="literal">create-drop</tt>
                            </p></td></tr><tr><td><tt class="literal">hibernate.cglib.use_reflection_optimizer</tt></td><td>
                            Enables use of CGLIB instead of runtime reflection (System-level
                            property). Reflection can sometimes be useful when troubleshooting,
                            note that Hibernate always requires CGLIB even if you turn off the
                            optimizer. You can not set this property in <tt class="literal">hibernate.cfg.xml</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.4.1.&nbsp;SQL Dialects</h3></div></div><div></div></div><p>
                You should always set the <tt class="literal">hibernate.dialect</tt> property to the correct
                <tt class="literal">org.hibernate.dialect.Dialect</tt> subclass for your database. If you
                specify a dialect, Hibernate will use sensible defaults for some of the
                other properties listed above, saving you the effort of specifying them manually.
            </p><div class="table"><a name="sql-dialects"></a><p class="title"><b>Table&nbsp;3.8.&nbsp;Hibernate SQL Dialects (<tt class="literal">hibernate.dialect</tt>)</b></p><table summary="Hibernate SQL Dialects (hibernate.dialect)" border="1"><colgroup><col><col></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">org.hibernate.dialect.DB2Dialect</tt></td></tr><tr><td>DB2 AS/400</td><td><tt class="literal">org.hibernate.dialect.DB2400Dialect</tt></td></tr><tr><td>DB2 OS390</td><td><tt class="literal">org.hibernate.dialect.DB2390Dialect</tt></td></tr><tr><td>PostgreSQL</td><td><tt class="literal">org.hibernate.dialect.PostgreSQLDialect</tt></td></tr><tr><td>MySQL</td><td><tt class="literal">org.hibernate.dialect.MySQLDialect</tt></td></tr><tr><td>MySQL with InnoDB</td><td><tt class="literal">org.hibernate.dialect.MySQLInnoDBDialect</tt></td></tr><tr><td>MySQL with MyISAM</td><td><tt class="literal">org.hibernate.dialect.MySQLMyISAMDialect</tt></td></tr><tr><td>Oracle (any version)</td><td><tt class="literal">org.hibernate.dialect.OracleDialect</tt></td></tr><tr><td>Oracle 9i/10g</td><td><tt class="literal">org.hibernate.dialect.Oracle9Dialect</tt></td></tr><tr><td>Sybase</td><td><tt class="literal">org.hibernate.dialect.SybaseDialect</tt></td></tr><tr><td>Sybase Anywhere</td><td><tt class="literal">org.hibernate.dialect.SybaseAnywhereDialect</tt></td></tr><tr><td>Microsoft SQL Server</td><td><tt class="literal">org.hibernate.dialect.SQLServerDialect</tt></td></tr><tr><td>SAP DB</td><td><tt class="literal">org.hibernate.dialect.SAPDBDialect</tt></td></tr><tr><td>Informix</td><td><tt class="literal">org.hibernate.dialect.InformixDialect</tt></td></tr><tr><td>HypersonicSQL</td><td><tt class="literal">org.hibernate.dialect.HSQLDialect</tt></td></tr><tr><td>Ingres</td><td><tt class="literal">org.hibernate.dialect.IngresDialect</tt></td></tr><tr><td>Progress</td><td><tt class="literal">org.hibernate.dialect.ProgressDialect</tt></td></tr><tr><td>Mckoi SQL</td><td><tt class="literal">org.hibernate.dialect.MckoiDialect</tt></td></tr><tr><td>Interbase</td><td><tt class="literal">org.hibernate.dialect.InterbaseDialect</tt></td></tr><tr><td>Pointbase</td><td><tt class="literal">org.hibernate.dialect.PointbaseDialect</tt></td></tr><tr><td>FrontBase</td><td><tt class="literal">org.hibernate.dialect.FrontbaseDialect</tt></td></tr><tr><td>Firebird</td><td><tt class="literal">org.hibernate.dialect.FirebirdDialect</tt></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.4.2.&nbsp;Outer Join Fetching</h3></div></div><div></div></div><p>
                If your database supports ANSI, Oracle or Sybase style outer joins, <span class="emphasis"><em>outer join
                fetching</em></span> will often increase performance by limiting the number of round
                trips to and from the database (at the cost of possibly more work performed by
                the database itself). Outer join fetching allows a whole graph of objects connected
                by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved 
                in a single SQL <tt class="literal">SELECT</tt>.
            </p><p>
                Outer join fetching may be disabled <span class="emphasis"><em>globally</em></span> by setting
                the property <tt class="literal">hibernate.max_fetch_depth</tt> to <tt class="literal">0</tt>.
                A setting of <tt class="literal">1</tt> or higher enables outer join fetching for
                one-to-one and many-to-one associations which have been mapped with 
                <tt class="literal">fetch="join"</tt>.
            </p><p>
                See <a href="performance.html#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-binarystreams"></a>3.4.3.&nbsp;Binary Streams</h3></div></div><div></div></div><p>
                Oracle limits the size of <tt class="literal">byte</tt> arrays that may
                be passed to/from its JDBC driver. If you wish to use large instances of
                <tt class="literal">binary</tt> or <tt class="literal">serializable</tt> type, you should
                enable <tt class="literal">hibernate.jdbc.use_streams_for_binary</tt>.
                <span class="emphasis"><em>This is a system-level setting only.</em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.4.4.&nbsp;Second-level and query cache</h3></div></div><div></div></div><p>
                The properties prefixed by <tt class="literal">hibernate.cache</tt>
                allow you to use a process or cluster scoped second-level cache system
                with Hibernate. See the <a href="performance.html#performance-cache" title="19.2.&nbsp;The Second Level Cache">Section&nbsp;19.2, &#8220;The Second Level Cache&#8221;</a> for
                more details.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.4.5.&nbsp;Query Language Substitution</h3></div></div><div></div></div><p>
                You may define new Hibernate query tokens using <tt class="literal">hibernate.query.substitutions</tt>.
                For example:
            </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>
                would cause the tokens <tt class="literal">true</tt> and <tt class="literal">false</tt> to be translated to
                integer literals in the generated SQL.
            </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>
                would allow you to rename the SQL <tt class="literal">LOWER</tt> function.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-statistics"></a>3.4.6.&nbsp;Hibernate statistics</h3></div></div><div></div></div><p>
                If you enable <tt class="literal">hibernate.generate_statistics</tt>, Hibernate will 
                expose a number of metrics that are useful when tuning a running system via
                <tt class="literal">SessionFactory.getStatistics()</tt>. Hibernate can even be configured
                to expose these statistics via JMX. Read the Javadoc of the interfaces in
                <tt class="literal">org.hibernate.stats</tt> for more information.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.5.&nbsp;Logging</h2></div></div><div></div></div><p>
            Hibernate logs various events using Apache commons-logging.
        </p><p>
            The commons-logging service will direct output to either Apache Log4j
            (if you include <tt class="literal">log4j.jar</tt> in your classpath) or
            JDK1.4 logging (if running under JDK1.4 or above). You may download
            Log4j from <tt class="literal">http://jakarta.apache.org</tt>.
            To use Log4j you will need to place a <tt class="literal">log4j.properties</tt>
            file in your classpath, an example properties file is distributed with
            Hibernate in the <tt class="literal">src/</tt> directory.
        </p><p>
            We strongly recommend that you familiarize yourself with Hibernate's log
            messages. A lot of work has been put into making the Hibernate log as
            detailed as possible, without making it unreadable. It is an essential
            troubleshooting device. The most interesting log categories are the
            following:
        </p><div class="table"><a name="log-categories"></a><p class="title"><b>Table&nbsp;3.9.&nbsp;Hibernate Log Categories</b></p><table summary="Hibernate Log Categories" border="1"><colgroup><col><col></colgroup><thead><tr><th>Category</th><th>Function</th></tr></thead><tbody><tr><td><tt class="literal">org.hibernate.SQL</tt></td><td>Log all SQL DML statements as they are executed</td></tr><tr><td><tt class="literal">org.hibernate.type</tt></td><td>Log all JDBC parameters</td></tr><tr><td><tt class="literal">org.hibernate.tool.hbm2ddl</tt></td><td>Log all SQL DDL statements as they are executed</td></tr><tr><td><tt class="literal">org.hibernate.pretty</tt></td><td>
                                Log the state of all entities (max 20 entities) associated
                                with the session at flush time
                            </td></tr><tr><td><tt class="literal">org.hibernate.cache</tt></td><td>Log all second-level cache activity</td></tr><tr><td><tt class="literal">org.hibernate.transaction</tt></td><td>Log transaction related activity</td></tr><tr><td><tt class="literal">org.hibernate.jdbc</tt></td><td>Log all JDBC resource acquisition</td></tr><tr><td><tt class="literal">org.hibernate.hql.ast.AST</tt></td><td>
                                Log HQL and SQL ASTs during query parsing
                            </td></tr><tr><td><tt class="literal">org.hibernate.secure</tt></td><td>Log all JAAS authorization requests</td></tr><tr><td><tt class="literal">org.hibernate</tt></td><td>
                                Log everything (a lot of information, but very useful for
                                troubleshooting)
                            </td></tr></tbody></table></div><p>
            When developing applications with Hibernate, you should almost always work with
            <tt class="literal">debug</tt> enabled for the category <tt class="literal">org.hibernate.SQL</tt>,
            or, alternatively, the property <tt class="literal">hibernate.show_sql</tt> enabled.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.6.&nbsp;Implementing a <tt class="literal">NamingStrategy</tt></h2></div></div><div></div></div><p>
            The interface <tt class="literal">org.hibernate.cfg.NamingStrategy</tt> allows you
            to specify a "naming standard" for database objects and schema elements.
        </p><p>
            You may provide rules for automatically generating database identifiers from
            Java identifiers or for processing "logical" column and table names given in
            the mapping file into  "physical" table and column names. This feature helps
            reduce the verbosity of the mapping document, eliminating repetitive noise
            (<tt class="literal">TBL_</tt> prefixes, for example). The default strategy used by
            Hibernate is quite minimal.
        </p><p>
            You may specify a different strategy by calling
            <tt class="literal">Configuration.setNamingStrategy()</tt> before adding mappings:
        </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p>
            <tt class="literal">org.hibernate.cfg.ImprovedNamingStrategy</tt> is a built-in
            strategy that might be a useful starting point for some applications.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.7.&nbsp;XML configuration file</h2></div></div><div></div></div><p>
            An alternative approach to configuration is to specify a full configuration in
            a file named <tt class="literal">hibernate.cfg.xml</tt>. This file can be used as a
            replacement for the <tt class="literal">hibernate.properties</tt> file or, if both
            are present, to override properties.
        </p><p>
            The XML configuration file is by default expected to be in the root o
            your <tt class="literal">CLASSPATH</tt>. Here is an example:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;java:/comp/env/jdbc/MyDB&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            org.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

        &lt;!-- cache settings --&gt;
        &lt;class-cache class="org.hibernate.auction.Item" usage="read-write"/&gt;
        &lt;class-cache class="org.hibernate.auction.Bid" usage="read-only"/&gt;
        &lt;collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
            As you can see, the advantage of this approach is the externalization of the
            mapping file names to configuration. The <tt class="literal">hibernate.cfg.xml</tt>
            is also more convenient once you have to tune the Hibernate cache. Note that is
            your choice to use either <tt class="literal">hibernate.properties</tt> or
            <tt class="literal">hibernate.cfg.xml</tt>, both are equivalent, except for the above
            mentioned benefits of using the XML syntax.
        </p><p>
           With the XML configuration, starting Hibernate is then as simple as
       </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>
           You can pick a different XML configuration file using
       </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-j2ee"></a>3.8.&nbsp;J2EE Application Server integration</h2></div></div><div></div></div><p>
            Hibernate has the following integration points for J2EE infrastructure:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>Container-managed datasources</em></span>: Hibernate can use
                JDBC connections managed by the container and provided through JNDI. Usually,
                a JTA compatible <tt class="literal">TransactionManager</tt> and a
                <tt class="literal">ResourceManager</tt> take care of transaction management (CMT),
                esp. distributed transaction handling across several datasources. You may
                of course also demarcate transaction boundaries programatically (BMT) or
                you might want to use the optional Hibernate <tt class="literal">Transaction</tt>
                API for this to keep your code portable.
                </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>Automatic JNDI binding</em></span>: Hibernate can bind its
                <tt class="literal">SessionFactory</tt> to JNDI after startup.
                </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>JTA Session binding:</em></span> The Hibernate <tt class="literal">Session</tt>
                may be automatically bound to the scope of JTA transactions. Simply
                lookup the <tt class="literal">SessionFactory</tt> from JNDI and get the current
                <tt class="literal">Session</tt>. Let Hibernate take care of flushing and closing the
                <tt class="literal">Session</tt> when your JTA transaction completes. Transaction
                demarcation is either declarative (CMT) or programmatic (BMT/UserTransaction).
                </p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>
                <span class="emphasis"><em>JMX deployment:</em></span> If you have a JMX capable application server
                (e.g. JBoss AS), you can chose to deploy Hibernate as a managed MBean. This saves
                you the one line startup code to build your <tt class="literal">SessionFactory</tt> from
                a <tt class="literal">Configuration</tt>. The container will startup your
                <tt class="literal">HibernateService</tt>, and ideally also take care of service
                dependencies (Datasource has to be available before Hibernate starts, etc).
                </p></li></ul></div><p>
            Depending on your environment, you might have to set the configuration option
            <tt class="literal">hibernate.connection.aggressive_release</tt> to true if your
            application server shows "connection containment" exceptions.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-transactionstrategy"></a>3.8.1.&nbsp;Transaction strategy configuration</h3></div></div><div></div></div><p>
                The Hibernate <tt class="literal">Session</tt> API is independent of any transaction
                demarcation system in your architecture. If you let Hibernate use JDBC directly,
                through a connection pool, you may begin and end your transactions by calling
                the JDBC API. If you run in a J2EE application server, you might want to use bean-managed
                transactions and call the JTA API and <tt class="literal">UserTransaction</tt> when needed.
            </p><p>
                To keep your code portable between these two (and other) environments we recommend the optional
                Hibernate <tt class="literal">Transaction</tt> API, which wraps and hides the underlying system.
                You have to specify a factory class for <tt class="literal">Transaction</tt> instances by setting the
                Hibernate configuration property <tt class="literal">hibernate.transaction.factory_class</tt>.
            </p><p>
                There are three standard (built-in) choices:
            </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">org.hibernate.transaction.JDBCTransactionFactory</tt></span></dt><dd><p>delegates to database (JDBC) transactions (default)</p></dd><dt><span class="term"><tt class="literal">org.hibernate.transaction.JTATransactionFactory</tt></span></dt><dd><p>
                            delegates to container-managed transaction if an existing transaction is
                            underway in this context (e.g. EJB session bean method), otherwise
                            a new transaction is started and bean-managed transaction are used.
                        </p></dd><dt><span class="term"><tt class="literal">org.hibernate.transaction.CMTTransactionFactory</tt></span></dt><dd><p>delegates to container-managed JTA transactions</p></dd></dl></div><p>
                You may also define your own transaction strategies (for a CORBA transaction service,
                for example).
            </p><p>
                Some features in Hibernate (i.e. the second level cache, Contextual Sessions with JTA, etc.)
                require access to the JTA <tt class="literal">TransactionManager</tt> in a managed environment.
                In an application server you have to specify how Hibernate should obtain a reference to the
                <tt class="literal">TransactionManager</tt>, since J2EE does not standardize a single mechanism:
            </p><div class="table"><a name="jtamanagerlookup"></a><p class="title"><b>Table&nbsp;3.10.&nbsp;JTA TransactionManagers</b></p><table summary="JTA TransactionManagers" border="1"><colgroup><col><col></colgroup><thead><tr><th>Transaction Factory</th><th align="center">Application Server</th></tr></thead><tbody><tr><td><tt class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</tt></td><td align="center">JBoss</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</tt></td><td align="center">Weblogic</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</tt></td><td align="center">WebSphere</td></tr><tr><td><tt class="literal">org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</tt></td><td align="center">WebSphere 6</td></tr><tr><td><tt class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</tt></td><td align="center">Orion</td></tr><tr><td><tt class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</tt></td><td align="center">Resin</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</tt></td><td align="center">JOTM</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</tt></td><td align="center">JOnAS</td></tr><tr><td><tt class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</tt></td><td align="center">JRun4</td></tr><tr><td><tt class="literal">org.hibernate.transaction.BESTransactionManagerLookup</tt></td><td align="center">Borland ES</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-jndi"></a>3.8.2.&nbsp;JNDI-bound <tt class="literal">SessionFactory</tt></h3></div></div><div></div></div><p>
                A JNDI bound Hibernate <tt class="literal">SessionFactory</tt> can simplify the lookup
                of the factory and the creation of new <tt class="literal">Session</tt>s. Note that this
                is not related to a JNDI bound <tt class="literal">Datasource</tt>, both simply use the
                same registry!
            </p><p>
                If you wish to have the <tt class="literal">SessionFactory</tt> bound to a JNDI namespace, specify
                a name (eg. <tt class="literal">java:hibernate/SessionFactory</tt>) using the property
                <tt class="literal">hibernate.session_factory_name</tt>. If this property is omitted, the
                <tt class="literal">SessionFactory</tt> will not be bound to JNDI. (This is especially useful in
                environments with a read-only JNDI default implementation, e.g. Tomcat.)
            </p><p>
                When binding the <tt class="literal">SessionFactory</tt> to JNDI, Hibernate will use the values of
                <tt class="literal">hibernate.jndi.url</tt>, <tt class="literal">hibernate.jndi.class</tt> to instantiate
                an initial context. If they are not specified, the default <tt class="literal">InitialContext</tt>
                will be used.
            </p><p>
                Hibernate will automatically place the <tt class="literal">SessionFactory</tt> in JNDI after
                you call <tt class="literal">cfg.buildSessionFactory()</tt>. This means you will at least have
                this call in some startup code (or utility class) in your application, unless you use
                JMX deployment with the <tt class="literal">HibernateService</tt> (discussed later).
            </p><p>
                If you use a JNDI <tt class="literal">SessionFactory</tt>, an EJB or any other class may
                obtain the  <tt class="literal">SessionFactory</tt> using a JNDI lookup.
            </p><p>
                We recommend that you bind the <tt class="literal">SessionFactory</tt> to JNDI in
                a managend environment and use a <tt class="literal">static</tt> singleton otherwise.
                To shield your application code from these details, we also recommend to hide the
                actual lookup code for a <tt class="literal">SessionFactory</tt> in a helper class,
                such as <tt class="literal">HibernateUtil.getSessionFactory()</tt>. Note that such a
                class is also a convenient way to startup Hibernate&#8212;see chapter 1.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-j2ee-currentsession"></a>3.8.3.&nbsp;Current Session context management with JTA</h3></div></div><div></div></div><p>
                The easiest way to handle <tt class="literal">Session</tt>s and transactions is
                Hibernates automatic "current" <tt class="literal">Session</tt> management.
                See the discussion of <a href="architecture.html#architecture-current-session" title="2.5.&nbsp;Contextual Sessions">Section&nbsp;2.5, &#8220;Contextual Sessions&#8221;</a>.
                Using the <tt class="literal">"jta"</tt> session context, if there is no Hibernate
                <tt class="literal">Session</tt> associated with the current JTA transaction, one will
	            be started and associated with that JTA transaction the first time you call
	            <tt class="literal">sessionFactory.getCurrentSession()</tt>. The <tt class="literal">Session</tt>s
	            retrieved via <tt class="literal">getCurrentSession()</tt> in <tt class="literal">"jta"</tt> context
	            will be set to automatically flush before the transaction completes, close
	            after the transaction completes, and aggressively release JDBC connections
	            after each statement.  This allows the <tt class="literal">Session</tt>s to
	            be managed by the lifecycle of the JTA transaction to which it is associated,
	            keeping user code clean of such management concerns. Your code can either use
	            JTA programmatically through <tt class="literal">UserTransaction</tt>, or (recommended
	            for portable code) use the Hibernate <tt class="literal">Transaction</tt> API to set
	            transaction boundaries. If you run in an EJB container, declarative transaction
	            demarcation with CMT is preferred.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-j2ee-jmx"></a>3.8.4.&nbsp;JMX deployment</h3></div></div><div></div></div><p>
                The line <tt class="literal">cfg.buildSessionFactory()</tt> still has to be executed
                somewhere to get a <tt class="literal">SessionFactory</tt> into JNDI. You can do this
                either in a <tt class="literal">static</tt> initializer block (like the one in
                <tt class="literal">HibernateUtil</tt>) or you deploy Hibernate as a <span class="emphasis"><em>managed
                service</em></span>.
            </p><p>
                Hibernate is distributed with <tt class="literal">org.hibernate.jmx.HibernateService</tt>
                for deployment on an application server with JMX capabilities, such as JBoss AS.
                The actual deployment and configuration is vendor specific. Here is an example
                <tt class="literal">jboss-service.xml</tt> for JBoss 4.0.x:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;server&gt;

&lt;mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory"&gt;

    &lt;!-- Required services --&gt;
    &lt;depends&gt;jboss.jca:service=RARDeployer&lt;/depends&gt;
    &lt;depends&gt;jboss.jca:service=LocalTxCM,name=HsqlDS&lt;/depends&gt;

    &lt;!-- Bind the Hibernate service to JNDI --&gt;
    &lt;attribute name="JndiName"&gt;java:/hibernate/SessionFactory&lt;/attribute&gt;

    &lt;!-- Datasource settings --&gt;
    &lt;attribute name="Datasource"&gt;java:HsqlDS&lt;/attribute&gt;
    &lt;attribute name="Dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/attribute&gt;

    &lt;!-- Transaction integration --&gt;
    &lt;attribute name="TransactionStrategy"&gt;
        org.hibernate.transaction.JTATransactionFactory&lt;/attribute&gt;
    &lt;attribute name="TransactionManagerLookupStrategy"&gt;
        org.hibernate.transaction.JBossTransactionManagerLookup&lt;/attribute&gt;
    &lt;attribute name="FlushBeforeCompletionEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="AutoCloseSessionEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Fetching options --&gt;
    &lt;attribute name="MaximumFetchDepth"&gt;5&lt;/attribute&gt;

    &lt;!-- Second-level caching --&gt;
    &lt;attribute name="SecondLevelCacheEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="CacheProviderClass"&gt;org.hibernate.cache.EhCacheProvider&lt;/attribute&gt;
    &lt;attribute name="QueryCacheEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Logging --&gt;
    &lt;attribute name="ShowSqlEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Mapping files --&gt;
    &lt;attribute name="MapResources"&gt;auction/Item.hbm.xml,auction/Category.hbm.xml&lt;/attribute&gt;

&lt;/mbean&gt;

&lt;/server&gt;</pre><p>
                This file is deployed in a directory called <tt class="literal">META-INF</tt> and packaged
                in a JAR file with the extension <tt class="literal">.sar</tt> (service archive). You also need
                to package Hibernate, its required third-party libraries, your compiled persistent classes,
                as well as your mapping files in the same archive. Your enterprise beans (usually session
                beans) may be kept in their own JAR file, but you may include this EJB JAR file in the
                main service archive to get a single (hot-)deployable unit. Consult the JBoss AS
                documentation for more information about JMX service and EJB deployment.
            </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="architecture.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="persistent-classes.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Architecture&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Persistent Classes</td></tr></table></div></body></html>